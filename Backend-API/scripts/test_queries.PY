from pyArango.connection import Connection
import os
from dotenv import load_dotenv
import json
from datetime import datetime

load_dotenv()

def get_db():
    """Get database connection"""
    conn = Connection(
        arangoURL=os.getenv('ARANGO_HOST'),
        username=os.getenv('ARANGO_USERNAME'),
        password=os.getenv('ARANGO_PASSWORD')
    )
    return conn[os.getenv('ARANGO_DATABASE')]

def print_section(title):
    """Print section header"""
    print("\n" + "=" * 80)
    print(f" {title}")
    print("=" * 80)

def print_subsection(title):
    """Print subsection header"""
    print(f"\nüìã {title}")
    print("-" * 80)

# ============================================================================
# PH·∫¶N 1: TRUY V·∫§N C∆† B·∫¢N
# ============================================================================

def test_basic_queries():
    """Test basic CRUD and filter queries"""
    print_section("PH·∫¶N 1: TRUY V·∫§N C∆† B·∫¢N")
    db = get_db()
    
    # 1. Read all stations
    print_subsection("1. L·∫•y t·∫•t c·∫£ c√°c tr·∫°m xe bu√Ωt")
    aql = """
    FOR station IN stations
        SORT station.name
        LIMIT 10
        RETURN {
            id: station.station_id,
            name: station.name,
            address: CONCAT(station.address.street, ", ", station.address.ward),
            type: station.type,
            status: station.status
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    stations = list(result)
    print(f"‚úÖ T√¨m th·∫•y {len(stations)} tr·∫°m (hi·ªÉn th·ªã 10 ƒë·∫ßu ti√™n)")
    for s in stations:
        print(f"   ‚Ä¢ {s['name']} ({s['type']}) - {s['address']}")
    
    # 2. Filter - Active routes
    print_subsection("2. C√°c tuy·∫øn xe ƒëang ho·∫°t ƒë·ªông")
    aql = """
    FOR route IN routes
        FILTER route.status == "active"
        SORT route.route_code
        RETURN {
            code: route.route_code,
            name: route.route_name,
            type: route.type,
            frequency: route.frequency
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    routes = list(result)
    print(f"‚úÖ T·ªïng s·ªë tuy·∫øn ho·∫°t ƒë·ªông: {len(routes)}")
    for r in routes[:5]:
        print(f"   ‚Ä¢ Tuy·∫øn {r['code']}: {r['name']} ({r['type']}) - {r['frequency']} ph√∫t/chuy·∫øn")
    
    # 3. Count by type
    print_subsection("3. Th·ªëng k√™ tr·∫°m theo lo·∫°i")
    aql = """
    FOR station IN stations
        COLLECT type = station.type WITH COUNT INTO total
        SORT total DESC
        RETURN {
            type: type,
            count: total
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    stats = list(result)
    for s in stats:
        type_label = {
            'terminal': 'B·∫øn xe ƒë·∫ßu cu·ªëi',
            'intermediate': 'Tr·∫°m trung gian',
            'stop': 'ƒêi·ªÉm d·ª´ng'
        }.get(s['type'], s['type'])
        print(f"   ‚Ä¢ {type_label}: {s['count']} tr·∫°m")
    
    # 4. Vehicles by manufacturer
    print_subsection("4. S·ªë xe theo h√£ng s·∫£n xu·∫•t")
    aql = """
    FOR vehicle IN vehicles
        COLLECT manufacturer = vehicle.manufacturer WITH COUNT INTO total
        SORT total DESC
        RETURN {
            manufacturer: manufacturer,
            count: total
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    manufacturers = list(result)
    for m in manufacturers:
        print(f"   ‚Ä¢ {m['manufacturer']}: {m['count']} xe")
    
    # 5. Complex filter
    print_subsection("5. Xe ho·∫°t ƒë·ªông c√≥ ƒëi·ªÅu h√≤a v√† WiFi")
    aql = """
    FOR vehicle IN vehicles
        FILTER vehicle.status == "active" 
            AND vehicle.features.air_conditioning == true
            AND vehicle.features.wifi == true
        RETURN {
            plate: vehicle.license_plate,
            type: vehicle.type,
            year: vehicle.year,
            capacity: vehicle.capacity
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    vehicles = list(result)
    print(f"‚úÖ T√¨m th·∫•y {len(vehicles)} xe")
    for v in vehicles[:5]:
        print(f"   ‚Ä¢ {v['plate']} ({v['type']}) - NƒÉm {v['year']} - {v['capacity']} ch·ªó")


# ============================================================================
# PH·∫¶N 2: TRUY V·∫§N GRAPH C∆† B·∫¢N
# ============================================================================

def test_graph_basic():
    """Test basic graph queries"""
    print_section("PH·∫¶N 2: TRUY V·∫§N GRAPH C∆† B·∫¢N")
    db = get_db()
    
    # 1. Routes with station count
    print_subsection("1. S·ªë l∆∞·ª£ng tr·∫°m c·ªßa m·ªói tuy·∫øn")
    aql = """
    FOR route IN routes
        LET stations = (
            FOR v, e IN OUTBOUND route serves
                RETURN v
        )
        SORT LENGTH(stations) DESC
        RETURN {
            code: route.route_code,
            name: route.route_name,
            total_stops: LENGTH(stations)
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    routes_with_stops = list(result)
    for r in routes_with_stops[:10]:
        print(f"   ‚Ä¢ Tuy·∫øn {r['code']}: {r['total_stops']} tr·∫°m")
    
    # 2. Find routes at a station
    print_subsection("2. T√¨m tuy·∫øn ƒëi qua m·ªôt tr·∫°m")
    station_name = "Ch·ª£ B·∫øn Th√†nh"
    aql = """
    FOR station IN stations
        FILTER station.name == @station_name
        FOR route, e IN INBOUND station serves
            SORT e.stop_order
            RETURN {
                code: route.route_code,
                name: route.route_name,
                stop_order: e.stop_order,
                arrival: e.arrival_offset
            }
    """
    result = db.AQLQuery(aql, bindVars={'station_name': station_name}, rawResults=True)
    routes_through = list(result)
    print(f"‚úÖ C√≥ {len(routes_through)} tuy·∫øn ƒëi qua {station_name}")
    for r in routes_through[:5]:
        print(f"   ‚Ä¢ Tuy·∫øn {r['code']}: D·ª´ng th·ª© {r['stop_order']} (+{r['arrival']} ph√∫t)")
    
    # 3. Top busiest stations
    print_subsection("3. Top 10 tr·∫°m b·∫≠n r·ªôn nh·∫•t")
    aql = """
    FOR station IN stations
        LET route_count = LENGTH(
            FOR route IN routes
                FOR v, e IN OUTBOUND route serves
                    FILTER v._key == station._key
                    RETURN 1
        )
        FILTER route_count > 0
        SORT route_count DESC
        LIMIT 10
        RETURN {
            name: station.name,
            routes: route_count,
            type: station.type,
            location: station.address.ward
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    busiest = list(result)
    for i, s in enumerate(busiest, 1):
        print(f"   {i:2d}. {s['name']}: {s['routes']} tuy·∫øn ({s['location']})")
    
    # 4. Vehicle utilization
    print_subsection("4. T·ª∑ l·ªá s·ª≠ d·ª•ng xe")
    aql = """
    LET total = LENGTH(vehicles)
    LET assigned = LENGTH(
        FOR v IN vehicles
            LET has_route = LENGTH(FOR r IN OUTBOUND v operates_on RETURN 1) > 0
            FILTER has_route
            RETURN 1
    )
    RETURN {
        total: total,
        assigned: assigned,
        unassigned: total - assigned,
        utilization_rate: (assigned / total) * 100
    }
    """
    result = db.AQLQuery(aql, rawResults=True)
    util = list(result)[0]
    print(f"   ‚Ä¢ T·ªïng s·ªë xe: {util['total']}")
    print(f"   ‚Ä¢ ƒê√£ ph√¢n c√¥ng: {util['assigned']}")
    print(f"   ‚Ä¢ Ch∆∞a ph√¢n c√¥ng: {util['unassigned']}")
    print(f"   ‚Ä¢ T·ª∑ l·ªá s·ª≠ d·ª•ng: {util['utilization_rate']:.2f}%")


# ============================================================================
# PH·∫¶N 3: TRUY V·∫§N GRAPH N√ÇNG CAO
# ============================================================================

def test_graph_advanced():
    """Test advanced graph queries"""
    print_section("PH·∫¶N 3: TRUY V·∫§N GRAPH N√ÇNG CAO")
    db = get_db()
    
    # 1. Graph traversal
    print_subsection("1. C√°c tr·∫°m c√≥ th·ªÉ ƒë·∫øn t·ª´ m·ªôt tr·∫°m (trong 3 b∆∞·ªõc)")
    start_station = "B·∫øn Xe Mi·ªÅn ƒê√¥ng"
    aql = """
    FOR station IN stations
        FILTER station.name == @start_station
        FOR v, e, p IN 1..3 OUTBOUND station connects
            RETURN DISTINCT {
                name: v.name,
                steps: LENGTH(p.edges),
                distance: SUM(p.edges[*].distance),
                duration: SUM(p.edges[*].duration)
            }
    """
    result = db.AQLQuery(aql, bindVars={'start_station': start_station}, rawResults=True)
    reachable = list(result)
    print(f"‚úÖ T·ª´ {start_station} c√≥ th·ªÉ ƒë·∫øn {len(reachable)} tr·∫°m")
    for r in reachable[:10]:
        print(f"   ‚Ä¢ {r['name']}: {r['distance']:.0f}m, {r['duration']:.0f} ph√∫t ({r['steps']} b∆∞·ªõc)")
    
    # 2. Shortest path
    print_subsection("2. ƒê∆∞·ªùng ƒëi ng·∫Øn nh·∫•t gi·ªØa 2 tr·∫°m")
    start = "B·∫øn Xe Mi·ªÅn ƒê√¥ng"
    end = "Ch·ª£ B·∫øn Th√†nh"
    aql = """
    FOR start IN stations
        FILTER start.name == @start
        FOR end_station IN stations
            FILTER end_station.name == @end
            LET path = (
                FOR v, e IN OUTBOUND SHORTEST_PATH start TO end_station connects
                    RETURN {
                        station: v.name,
                        distance: e.distance,
                        duration: e.duration
                    }
            )
            FILTER LENGTH(path) > 0
            RETURN {
                path: path,
                total_distance: SUM(path[*].distance),
                total_duration: SUM(path[*].duration)
            }
    """
    result = db.AQLQuery(aql, bindVars={'start': start, 'end': end}, rawResults=True)
    paths = list(result)
    
    if paths:
        path_data = paths[0]
        print(f"‚úÖ T√¨m th·∫•y ƒë∆∞·ªùng ƒëi t·ª´ {start} ƒë·∫øn {end}")
        print(f"   ‚Ä¢ Kho·∫£ng c√°ch: {path_data['total_distance']:.0f}m")
        print(f"   ‚Ä¢ Th·ªùi gian: {path_data['total_duration']:.0f} ph√∫t")
        print(f"   ‚Ä¢ L·ªô tr√¨nh:")
        for i, p in enumerate(path_data['path'], 1):
            print(f"      {i}. {p['station']}")
    else:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng ƒëi tr·ª±c ti·∫øp")
    
    # 3. K Shortest Paths
    print_subsection("3. Top 3 ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t")
    start = "S√¢n Bay T√¢n S∆°n Nh·∫•t"
    end = "Landmark 81"
    aql = """
    FOR start IN stations
        FILTER start.name == @start
        FOR end_station IN stations
            FILTER end_station.name == @end
            FOR path IN OUTBOUND K_SHORTEST_PATHS start TO end_station connects
                LIMIT 3
                LET total_distance = SUM(path.edges[*].distance)
                LET total_duration = SUM(path.edges[*].duration)
                RETURN {
                    path: path.vertices[*].name,
                    distance: total_distance,
                    duration: total_duration,
                    stops: LENGTH(path.vertices)
                }
    """
    result = db.AQLQuery(aql, bindVars={'start': start, 'end': end}, rawResults=True)
    k_paths = list(result)
    
    if k_paths:
        print(f"‚úÖ T√¨m th·∫•y {len(k_paths)} l·ªô tr√¨nh t·ª´ {start} ƒë·∫øn {end}")
        for i, p in enumerate(k_paths, 1):
            print(f"\n   L·ªô tr√¨nh {i}:")
            print(f"   ‚Ä¢ Kho·∫£ng c√°ch: {p['distance']:.0f}m")
            print(f"   ‚Ä¢ Th·ªùi gian: {p['duration']:.0f} ph√∫t")
            print(f"   ‚Ä¢ S·ªë tr·∫°m: {p['stops']}")
            print(f"   ‚Ä¢ ƒê∆∞·ªùng ƒëi: {' ‚Üí '.join(p['path'][:3])} ... {p['path'][-1]}")
    else:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng ƒëi")


# ============================================================================
# PH·∫¶N 4: TRUY V·∫§N PH·ª®C T·∫†P
# ============================================================================

def test_complex_queries():
    """Test complex business queries"""
    print_section("PH·∫¶N 4: TRUY V·∫§N PH·ª®C T·∫†P")
    db = get_db()
    
    # 1. Complete route details
    print_subsection("1. Chi ti·∫øt ƒë·∫ßy ƒë·ªß c·ªßa m·ªôt tuy·∫øn")
    route_code = "01"
    aql = """
    FOR route IN routes
        FILTER route.route_code == @route_code
        LET stations = (
            FOR v, e IN OUTBOUND route serves
                SORT e.stop_order
                RETURN {
                    name: v.name,
                    order: e.stop_order,
                    arrival: e.arrival_offset,
                    main: e.is_main_stop,
                    type: v.type
                }
        )
        LET assigned_vehicles = (
            FOR v, e IN INBOUND route operates_on
                RETURN {
                    plate: v.license_plate,
                    shift: e.shift,
                    type: v.type
                }
        )
        RETURN {
            route: route.route_name,
            code: route.route_code,
            type: route.type,
            frequency: route.frequency,
            fare: route.fare,
            stations: stations,
            vehicles: assigned_vehicles
        }
    """
    result = db.AQLQuery(aql, bindVars={'route_code': route_code}, rawResults=True)
    
    if result:
        route_detail = list(result)[0]
        print(f"‚úÖ Tuy·∫øn {route_detail['code']}: {route_detail['route']}")
        print(f"   ‚Ä¢ Lo·∫°i: {route_detail['type']}")
        print(f"   ‚Ä¢ T·∫ßn su·∫•t: {route_detail['frequency']} ph√∫t")
        print(f"   ‚Ä¢ Gi√° v√©: {route_detail['fare']['adult']:,}ƒë (ng∆∞·ªùi l·ªõn)")
        
        print(f"\n   üìç Danh s√°ch tr·∫°m ({len(route_detail['stations'])} tr·∫°m):")
        for s in route_detail['stations'][:10]:
            main = " ‚≠ê" if s['main'] else ""
            print(f"      {s['order']:2d}. {s['name']} (+{s['arrival']}'){main}")
        
        print(f"\n   üöå Xe ƒë∆∞·ª£c ph√¢n c√¥ng ({len(route_detail['vehicles'])} xe):")
        for v in route_detail['vehicles'][:5]:
            print(f"      ‚Ä¢ {v['plate']} ({v['type']}) - Ca {v['shift']}")
    else:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y tuy·∫øn {route_code}")
    
    # 2. Route coverage analysis
    print_subsection("2. Ph√¢n t√≠ch ƒë·ªô ph·ªß c·ªßa c√°c tuy·∫øn")
    aql = """
    FOR route IN routes
        LET stations = (
            FOR v, e IN OUTBOUND route serves
                RETURN v
        )
        LET wards = UNIQUE(stations[*].address.ward)
        LET coverage_score = LENGTH(wards) * LENGTH(stations)
        SORT coverage_score DESC
        LIMIT 10
        RETURN {
            code: route.route_code,
            name: route.route_name,
            total_stops: LENGTH(stations),
            wards_covered: LENGTH(wards),
            coverage_score: coverage_score
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    coverage = list(result)
    
    print(f"‚úÖ Top 10 tuy·∫øn c√≥ ƒë·ªô ph·ªß cao nh·∫•t:")
    for i, r in enumerate(coverage, 1):
        print(f"   {i:2d}. Tuy·∫øn {r['code']}: {r['total_stops']} tr·∫°m, {r['wards_covered']} ph∆∞·ªùng (Score: {r['coverage_score']})")
    
    # 3. Find alternative routes
    print_subsection("3. T√¨m c√°c tuy·∫øn thay th·∫ø")
    start = "Ch·ª£ B·∫øn Th√†nh"
    end = "Landmark 81"
    aql = """
    FOR start IN stations
        FILTER start.name == @start
        FOR end_station IN stations
            FILTER end_station.name == @end
            FOR route IN routes
                LET has_start = LENGTH(
                    FOR v, e IN OUTBOUND route serves
                        FILTER v._key == start._key
                        RETURN 1
                ) > 0
                LET has_end = LENGTH(
                    FOR v, e IN OUTBOUND route serves
                        FILTER v._key == end_station._key
                        RETURN 1
                ) > 0
                FILTER has_start AND has_end
                RETURN {
                    code: route.route_code,
                    name: route.route_name,
                    type: route.type,
                    frequency: route.frequency
                }
    """
    result = db.AQLQuery(aql, bindVars={'start': start, 'end': end}, rawResults=True)
    alternative_routes = list(result)
    
    if alternative_routes:
        print(f"‚úÖ T√¨m th·∫•y {len(alternative_routes)} tuy·∫øn tr·ª±c ti·∫øp t·ª´ {start} ƒë·∫øn {end}:")
        for r in alternative_routes:
            print(f"   ‚Ä¢ Tuy·∫øn {r['code']}: {r['name']} ({r['type']}) - {r['frequency']}'/chuy·∫øn")
    else:
        print(f"‚ö†Ô∏è  Kh√¥ng c√≥ tuy·∫øn tr·ª±c ti·∫øp. C·∫ßn ƒë·ªïi tuy·∫øn.")


# ============================================================================
# PH·∫¶N 5: JOURNEY PLANNING QUERIES
# ============================================================================

def test_journey_queries():
    """Test journey planning specific queries"""
    print_section("PH·∫¶N 5: JOURNEY PLANNING QUERIES")
    db = get_db()
    
    # 1. Find routes at a specific station
    print_subsection("1. T√¨m tuy·∫øn ƒëi qua m·ªôt tr·∫°m c·ª• th·ªÉ")
    station_id = "ST001"
    aql = """
    LET station = FIRST(
        FOR s IN stations
            FILTER s.station_id == @station_id
            RETURN s
    )
    
    FOR route, edge IN INBOUND station serves
        FILTER route.status == "active"
        
        LET all_stops = (
            FOR v, e IN OUTBOUND route serves
                SORT e.stop_order
                RETURN {
                    station_name: v.name,
                    stop_order: e.stop_order
                }
        )
        
        RETURN {
            route_code: route.route_code,
            route_name: route.route_name,
            stop_order: edge.stop_order,
            total_stops: LENGTH(all_stops),
            is_main_stop: edge.is_main_stop
        }
    """
    result = db.AQLQuery(aql, bindVars={'station_id': station_id}, rawResults=True)
    routes_at_station = list(result)
    
    if routes_at_station:
        print(f"‚úÖ T√¨m th·∫•y {len(routes_at_station)} tuy·∫øn ƒëi qua tr·∫°m {station_id}:")
        for r in routes_at_station:
            main = " ‚≠ê" if r['is_main_stop'] else ""
            print(f"   ‚Ä¢ Tuy·∫øn {r['route_code']}: D·ª´ng {r['stop_order']}/{r['total_stops']}{main}")
    else:
        print(f"‚ö†Ô∏è  Kh√¥ng c√≥ tuy·∫øn n√†o ƒëi qua tr·∫°m n√†y")
    
    # 2. Find transfer stations between two routes
    print_subsection("2. T√¨m tr·∫°m chuy·ªÉn ti·∫øp gi·ªØa 2 tuy·∫øn")
    route1_code = "01"
    route2_code = "09"
    aql = """
    LET route1_stations = (
        FOR route IN routes
            FILTER route.route_code == @route1_code
            FOR station, edge IN OUTBOUND route serves
                RETURN {
                    station: station,
                    stop_order: edge.stop_order
                }
    )
    
    LET route2_stations = (
        FOR route IN routes
            FILTER route.route_code == @route2_code
            FOR station, edge IN OUTBOUND route serves
                RETURN {
                    station: station,
                    stop_order: edge.stop_order
                }
    )
    
    FOR s1 IN route1_stations
        FOR s2 IN route2_stations
            FILTER s1.station.station_id == s2.station.station_id
            RETURN {
                station: s1.station,
                route1_stop: s1.stop_order,
                route2_stop: s2.stop_order
            }
    """
    result = db.AQLQuery(aql, bindVars={
        'route1_code': route1_code,
        'route2_code': route2_code
    }, rawResults=True)
    transfer_stations = list(result)
    
    if transfer_stations:
        print(f"‚úÖ T√¨m th·∫•y {len(transfer_stations)} tr·∫°m chuy·ªÉn ti·∫øp:")
        for t in transfer_stations:
            print(f"   ‚Ä¢ {t['station']['name']}")
            print(f"     - Tuy·∫øn {route1_code}: Tr·∫°m th·ª© {t['route1_stop']}")
            print(f"     - Tuy·∫øn {route2_code}: Tr·∫°m th·ª© {t['route2_stop']}")
    else:
        print(f"‚ö†Ô∏è  Kh√¥ng c√≥ tr·∫°m chuy·ªÉn ti·∫øp chung")
    
    # 3. Find nearby stations
    print_subsection("3. T√¨m tr·∫°m g·∫ßn m·ªôt t·ªça ƒë·ªô")
    lat, lng = 10.7769, 106.7009  # Trung t√¢m S√†i G√≤n
    radius = 2  # km
    aql = """
    FOR station IN stations
        LET distance = DISTANCE(
            station.location.latitude,
            station.location.longitude,
            @lat,
            @lng
        ) / 1000
        FILTER distance <= @radius
        SORT distance
        LIMIT 10
        RETURN {
            name: station.name,
            distance: distance,
            address: CONCAT(station.address.street, ", ", station.address.ward),
            type: station.type
        }
    """
    result = db.AQLQuery(aql, bindVars={
        'lat': lat,
        'lng': lng,
        'radius': radius
    }, rawResults=True)
    nearby = list(result)
    
    print(f"‚úÖ T√¨m th·∫•y {len(nearby)} tr·∫°m trong b√°n k√≠nh {radius}km:")
    for s in nearby:
        print(f"   ‚Ä¢ {s['name']}: {s['distance']:.2f}km ({s['type']})")


# ============================================================================
# PH·∫¶N 6: STATISTICS & ANALYTICS
# ============================================================================

def test_analytics_queries():
    """Test analytics and statistics queries"""
    print_section("PH·∫¶N 6: STATISTICS & ANALYTICS")
    db = get_db()
    
    # 1. Overall statistics
    print_subsection("1. Th·ªëng k√™ t·ªïng quan h·ªá th·ªëng")
    aql = """
    RETURN {
        total_stations: LENGTH(stations),
        total_routes: LENGTH(routes),
        total_vehicles: LENGTH(vehicles),
        active_routes: LENGTH(FOR r IN routes FILTER r.status == "active" RETURN 1),
        active_vehicles: LENGTH(FOR v IN vehicles FILTER v.status == "active" RETURN 1),
        total_connections: LENGTH(connects),
        total_serves: LENGTH(serves)
    }
    """
    result = db.AQLQuery(aql, rawResults=True)
    stats = list(result)[0]
    
    print(f"‚úÖ Th·ªëng k√™ t·ªïng quan:")
    print(f"   ‚Ä¢ T·ªïng s·ªë tr·∫°m: {stats['total_stations']}")
    print(f"   ‚Ä¢ T·ªïng s·ªë tuy·∫øn: {stats['total_routes']} (Ho·∫°t ƒë·ªông: {stats['active_routes']})")
    print(f"   ‚Ä¢ T·ªïng s·ªë xe: {stats['total_vehicles']} (Ho·∫°t ƒë·ªông: {stats['active_vehicles']})")
    print(f"   ‚Ä¢ K·∫øt n·ªëi gi·ªØa tr·∫°m: {stats['total_connections']}")
    print(f"   ‚Ä¢ Tuy·∫øn-Tr·∫°m: {stats['total_serves']}")
    
    # 2. Routes by type
    print_subsection("2. Ph√¢n lo·∫°i tuy·∫øn theo lo·∫°i")
    aql = """
    FOR route IN routes
        COLLECT type = route.type WITH COUNT INTO total
        RETURN {
            type: type,
            count: total,
            percentage: (total / LENGTH(routes)) * 100
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    route_types = list(result)
    
    for rt in route_types:
        type_label = {
            'normal': 'Th∆∞·ªùng',
            'express': 'Nhanh',
            'rapid': 'Express'
        }.get(rt['type'], rt['type'])
        print(f"   ‚Ä¢ {type_label}: {rt['count']} tuy·∫øn ({rt['percentage']:.1f}%)")
    
    # 3. Vehicle age distribution
    print_subsection("3. Ph√¢n b·ªë tu·ªïi xe")
    current_year = datetime.now().year
    aql = """
    FOR vehicle IN vehicles
        LET age = @current_year - vehicle.year
        COLLECT age_group = FLOOR(age / 5) * 5 WITH COUNT INTO total
        SORT age_group
        RETURN {
            age_range: CONCAT(age_group, "-", age_group + 4, " nƒÉm"),
            count: total
        }
    """
    result = db.AQLQuery(aql, bindVars={'current_year': current_year}, rawResults=True)
    age_dist = list(result)
    
    for ad in age_dist:
        print(f"   ‚Ä¢ {ad['age_range']}: {ad['count']} xe")
    
    # 4. Average route metrics
    print_subsection("4. Ch·ªâ s·ªë trung b√¨nh c·ªßa tuy·∫øn")
    aql = """
    FOR route IN routes
        LET stops_count = LENGTH(FOR v IN OUTBOUND route serves RETURN 1)
        COLLECT AGGREGATE
            avg_stops = AVG(stops_count),
            min_stops = MIN(stops_count),
            max_stops = MAX(stops_count),
            avg_frequency = AVG(route.frequency),
            avg_fare = AVG(route.fare.adult)
        RETURN {
            avg_stops: avg_stops,
            min_stops: min_stops,
            max_stops: max_stops,
            avg_frequency: avg_frequency,
            avg_fare: avg_fare
        }
    """
    result = db.AQLQuery(aql, rawResults=True)
    metrics = list(result)[0]
    
    print(f"   ‚Ä¢ S·ªë tr·∫°m trung b√¨nh: {metrics['avg_stops']:.1f}")
    print(f"   ‚Ä¢ S·ªë tr·∫°m √≠t nh·∫•t: {metrics['min_stops']}")
    print(f"   ‚Ä¢ S·ªë tr·∫°m nhi·ªÅu nh·∫•t: {metrics['max_stops']}")
    print(f"   ‚Ä¢ T·∫ßn su·∫•t trung b√¨nh: {metrics['avg_frequency']:.1f} ph√∫t")
    print(f"   ‚Ä¢ Gi√° v√© trung b√¨nh: {metrics['avg_fare']:,.0f}ƒë")


# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """Run all test queries"""
    print("\n")
    print("üöå" * 40)
    print(" " * 20 + "BUS MANAGEMENT SYSTEM")
    print(" " * 20 + "TEST QUERIES")
    print("üöå" * 40)
    
    try:
        # Test connection
        db = get_db()
        print("\n‚úÖ K·∫øt n·ªëi database th√†nh c√¥ng!")
        print(f"   Database: {os.getenv('ARANGO_DATABASE')}")
        print(f"   Host: {os.getenv('ARANGO_HOST')}")
        
        # Run all test suites
        test_basic_queries()
        test_graph_basic()
        test_graph_advanced()
        test_complex_queries()
        test_journey_queries()
        test_analytics_queries()
        
        # Summary
        print_section("‚úÖ HO√ÄN TH√ÄNH T·∫§T C·∫¢ TRUY V·∫§N")
        print("\nüéâ T·∫•t c·∫£ c√°c truy v·∫•n ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra th√†nh c√¥ng!")
        print("üìä H·ªá th·ªëng ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng")
        print("\n")
        
    except Exception as e:
        print(f"\n‚ùå L·ªñI: {str(e)}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())